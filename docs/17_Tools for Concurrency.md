# 17. 동시성 프로그래밍 도구

#### 다중코어 문제
- 무어의 법칙 붕괴: **수직적 확장** 에서 **수평적 확장** 으로 성능 향상의 패러다임 변화

#### 동시성 소프트웨어 작성
- 다중 스레드 프로그래밍
  - lock, mutex, semaphore등의 도구로 공유 상태에 대한 접근조정
  - **유령같은 원격 작용**(spooky action) 발생 가능
- 함수형 프로그래밍
  - 불변성과 순수성을 채용하여 다중 스레드 프로그래밍의 불확실성 제거
  - **액터 모델** 등의 부흥

## 17.1 `scala.sys.process` 패키지
- DB, 트랜잭션, 메시지큐, 프로세스 사이에서 파이프 등으로 서로의 상태를 조정하는 작은 동기적 프로세스

#### OS 프로세스의 실행&관리를 위한 DSL

[processes.sc](../src/main/scala/concurrency/process/processes.sc)

- `#>`: 파일이나 파이프를 덮어쓰거나, 두 번째 프로세스의 `stdin`에 연결
- `#>>`: 파일의 뒤에 덧붙이기 위한 것
- `#&&`: 왼쪽에 있는 프로세스가 성공한 경우에만 오른쪽 연산을 수행하는 2항 연산자
- `!`: 명령을 실행
- 모든 메서드는 `scala.sys.process.ProcessBuilder`를 반환

## 17.2 퓨처(`scala.concurrent.Future`)
- 비동기적으로 실행되는 작업들이 실행 시 블록되지 않고, 직접 I/O를 수행

#### 동작 특징

- `Future` 생성시, 제어는 바로 호출한 쪽으로 반환
- 반환값은 바로 사용되지 않고, 언젠가는 사용될 결과들에 대한 핸들러 역할 수행
- 퓨처가 완료될 때 까지 다른 작업 수행 가능
- 성공/실패 모두 가능한데 이를 처리하는 방법은 다양함

##### 열 가지 작업을 동시에 진행하고 그 결과를 조합하는 예제
[future-fold.sc](../src/main/scala/concurrency/futures/future-fold.sc)

- `Future`는 비동기 처리되기 때문에 내부의 로직(`print`문으로 확인)은 호출 순서대로 진행되지 않음
- `fold`는 `Future`를 호출한 순서대로 처리하기 때문에 결과는 순서대로 출력
- [`Future.fold`등 이와 비슷한 메서드](http://bit.ly/1pbjSQR) 는 비동기로 각각 새로운 `Future`를 반환
- 위 예제에서는 `Await.result` 호출부분에서만 Block
- 콜백: 결과를 기다리지 않고 특정 코드를 실행

##### 콜백 예제
[future-callbacks.sc](../src/main/scala/concurrency/futures/future-callbacks.sc)

- `Future`는 Monadic
  - `for`내장에 사용 가능
  - `map`, `flatMap`, `filter`등의 콤비네이터를 `Future`의 결과에 사용 가능

### 17.2.1 Async(`scala.async.Async`)
- Callback Hell 발생에 대한 대안
- Optional module for 2.10, 2.11

#### 기본 메서드
```scala
def async[T](body: => T): Future[T] // 비동기 계산을 시작하며 그에 대한 Future를 즉시 반환
def await[T](future: Future[T]): T  // 지정한 Future가 완료될 때까지 기다림
```

##### 비동기 호출을 순서대로 수행하는 예제
- 첫 번째 호출: 어떤 `id`에 맞는 *레코드* 가 있는지 결정
- 두 번째 호출: 위 *레코드* 를 가져옴 (실패시 *오류 레코드* 반환)

[async.sc](../src/main/scala/concurrency/async/async.sc)

#### Future의 한계
- `Async`로 다소 깔끔해 질 수 있지만 동기화된 코드만큼 깔끔하진 않다
- `Async`와 함께 사용하느냐와 관계없이 동시성을 위한 **전술** 이지 **전략** 은 아님
- 비동기 프로세스를 위한 오류처리나 확장성 지원등을 위한 **액터 모델** 로 극복


## 17.3 액터를 활용한 튼튼하고 확장성 있는 동시성 프로그래밍
#### Actor
- **메시지** 를 받아 그에 따라 동작을 수행하는 객체
- 선점하지 않고, 한 번에 메시지 하나만을 처리
- 도착 순서는 크게 중요치 않음(아닐 수 있다)
- 메시지를.. `내부적으로 처리` / `다른 액터에 전달` / `새 메시지를 생성해 전달`
- 메시지 처리중에 새 액터를 만들거나 메시지 처리 방법을 스스로 변경 가능(*기계 상태에서의 천이* 구현)

#### 액터의 동시성
- 메서드 호출과 달리 액터 메시지 송신은 보통 **비동기적** -> 전체에서 각 액션 수행 순서는 비결정적
- 액터도 메시지 응답중에 상태 변이가 가능하나 **권장하지 않음**
- 여러 클러스터에서 병렬로 수행 가능
- 전역 상태를 어떤 기분(?) 에 따라 관리 가능
- *다중 스레드* 기반의 동시성에서 발생 가능한 대부분의 문제를 회피

## 17.4 AKKA: 스칼라를 위한 액터
#### 관리 액터
- 하나 이상의 액터의 생명 주기 관찰
- 액터 실패시, 관리액터는 `재시작` / `종료` / `오류 무시` / 상위 관리 액터에 `처리 위임` 등의 동작

#### 재시작 전략
- **all-for-one**
  - 실패한 액터가 다른 액터들과 밀접하게 연관되어 있고
  - 모두 한 관리 액터 하에 존재하며
  - 모든 액터를 재시작하는게 최선인 경우
- **one-for-one**
  - 관리 대상 액터가 독립적이고
  - 한 액터의 실패가 다른 액터에 영향을 끼치지 않으며
  - 실패한 액터만 재시작 가능한 경우

---
- 일반 처리 로직과 오류처리 로직을 깔끔하게 분리
- 전체 구조 수준에서 오류처리 전략을 선택 가능
- 문제 발생시 **액터가 중단되도록 내벼러둘지** 에 대한 원칙 정립

#### 서비스를 호출하는 고객 인터페이스 예제
- `AkkaClient` -> `ServerActor` =`[dist]`=> `WorkerActor`s

##### 메시지
[Messages.scala](../src/main/scala/concurrency/akka/Messages.scala)  

- 액터 사이에 오가게 될 모든 메시지 정의

##### AkkaClient
[AkkaClient.scala](../src/main/scala/concurrency/akka/AkkaClient.scala)

- `main`에 위치한 고객 인터페이스
- 모두를 제어하는 `akka.actor.ActorSystem` 생성
- `ServerActor` 인스턴스 생성 후 처리 시작명령 메시지 전달
- REPL 인터페이스 제공

[application.conf](../src/main/resources/application.conf)

- TypeSafe의 `Config`라이브러리를 사용한 설정값 지정

##### ServerActor
- 작업을 여러 `WorkerActor`들에게 위임
- 블럭되지 않음

[ServerActor.scala](../src/main/scala/concurrency/akka/ServerActor.scala)

- `Actor.receive`
  - 메시지 도착시 매번 호출되는것은 아니고, 액터가 생성되면서 `Receive`를 반환해야 하는 경우 **단 한 번** 만 호출
  - 실제 메시지 도착 시 여러 번 호출되는 것은 `Receive`타입의 부분함수
  - 부분 함수의 메시지 처리 절에서는 `Actor.become`을 사용해 새로운 `Receive`가 모든 메시지를 처리하도록 상태 변경 가능
    - 예> `initial` 내부에서 `Start`를 받았을 때 하는 일
  - 모든 메시지에 대해 처리기인 `Receive`를 변경해 복잡한 기계 상태 구현도 가능
    - `FSM`트레이트(기계 상태를 편하게 정의할 수 있는 DSL)를 혼합하여 boilerplate를 줄일 수 있다
- `ServerActor`는 모든 작업자의 응답을 콘솔에 출력
  - `AkkaClient`는 액터가 아니기에 그쪽으로 리턴 불가
  - `Actor.sender` 호출시 실제로는 `ActorSystem.deadLetters` 리턴
- **`system.actorOf(Props[ServerActor], "server")`**
  - `ServerActor`를 만들기 위한 상용구
  - `new ServerActor`를 호출해 새로운 액터 생성이 불가능하고, `ActorRef`로 감싸야 하는데, `actorOf`가 이를 해결
  - `Props` 싱글턴 객체는 JVM 바이트코드가 만들어질 때 생기는 문제 해결을 위해 존재
    - 액터는 클러스터 환경에서 원격에 배포하기 위해 직렬화가 가능해야 함
    - 액터 인스턴스를 다른 인스턴스 내에서 생성시, 컴파일러는 해당 영역을 필요에 따라 닫으면서 외부 객체들을 포획 시도
      - 직렬화한 바이트 코드 내에 다른 클래스의 인스턴스를 포함시켜야 할 수도 있다는 의미
      - 이런 클래스 중 일부는 직렬이 불가능할 수 있고, 이로 인해 액터를 다른 노드에 전송 불가능
    - 외부 액터 인스턴스의 상태가 내포된 액터에 포획되어 원격 노드에서는 동작의 일관성이 깨질 가능성이 있음

##### WorkerActor
[WorkerActor.scala](../src/main/scala/concurrency/akka/WorkerActor.scala)

- **공유** 데이터 저장소를 시뮬레이션
- 키(`Long`) 값(`String`) 맵, CRUD지원


##### 실행
```
run-main concurrency.akka.AkkaClient
```

- 비동기적 연산이기에 스크립트 실행 시 마다 다른 결과 출력
- 액터 중 하나가 실패하는 경우 데이터 손실 발생
  - 아카 영속성 모듈: 재시작한 액터가 이전 인스턴스 상태로 복구될 수 있도록 액터 상태에 내구성이 있는 영속성 부여
- 액터에 직접 접근을 금지하고 핸들러인 `ActorRef`만을 통하는 이유
  - 액터 실패시 `ServerActor`의 작업 액터 목록이 비정상 상태가 되는 것 방지
- `ActorRef`는 매우 안정적 -> 훌륭한 **의존관계** 성립
  - 어떤 관리액터가 하위 액터를 재시작시 하우 이개터에 대한 `ActorRef`가 새 액터를 가리키도록 변경
  - 재시작 & 갱신 실패시 해당 `ActorRef`로 가는 모든 메시지는 `ActorSystem.deadLetters`로 전달
    - `ActorSystem.deadLetter`: 죽은 액터로 가는 모든 메시지를 저장
  - **`ActorRef`간 관계는 안정적이고 신뢰 가능**

### 17.4.1 액터: 마지막 고찰
#### 장점
- Akka의 효율적인 사용을 위한 다양한 패턴과 관용어 존재
- 액터 하나당 300Byte정도로 가벼움
  - 대규모의 단일 JVM시스템에서 수백만개 액터 생성 가능
  - 수많은 자율적 액터 관리는 상당히 어려운 일이지만, 상태가 없는 작업 액터라면 필요한 경우 관리 가능
- 수천 노드에 걸친 클러스터링 지원

#### 단점
- 타입 안정성이 부족
  - `Receive`가 `PartialFunction[Any, Unit]`의 Alias -> 어떤 액터가 수신가능한 메시지의 타입을 좁힐 수 있는 수단을 제공하지 않음
  - 액터가 예상 불가능한 메시지를 수신하는 경우 실행 시점에 판단 가능
  - 액터에 대한 모든 참조는 `ActorRef`이지 구체적 `Actor`타입이 아님
- 함수형 프로그래밍 모델이 아님
  - `Receive`는 `Unit`을 반환: 모든 것이 부수작업
  - `datastore`같은 변경 가능한 상태를 활용

#### 극복
- 스칼라와 아카는 변경 가능성을 강제로 제약하지 못하지만...
  - 내부 상태를 주의 깊게 캡슐화하고
  - 상태 변경에 대해 스레드 안정성 보장
  - 메시지를 불변 객체로 간주
- 개발자 스스로 정해진 원칙을 잘 따르면서 변경 가능성 사용하면 좋은 도구가 될 것


## 17.5 피클링과 스포어즈
- 데이터와 코드가 클러스터 내에서 이동할 수 있도록 빠른 직렬화 & 역직렬화 제어 필요
- 여러 다른 요구사항과의 균형을 이루어야 함
  - 예> JVM 언어가 아닌 언어, 스키마, 버전 변경 등

#### 피클링(Pickling)
- 소스에서 준비 코드를 최소화하며 서로 다른 백엔드 형식에 따라 끼워넣을 수 있는 구조를 제공

#### 스포어즈(Spores)
- 스포어: 안전한 클로저
- 클로저가 외부로 배분될 때 클로저 내부에 포획된 내용에 대한 처리 방법 제공
- 사용자가 명시적으로 스포어를 구축할 수 있는 API를 제공하고 이 API가 정확성을 보장

## 17.6 반응형 프로그래밍
#### 반응형 프로그래밍
- 어플리케이션이 서비스 요청에 반응 해야함
- *도움* 이 필요시 다른 서비스에 이벤트(혹은 메시지)를 전달

##### 함수형 반응형 프로그래밍(FRP)
- **데이터 흐름** 모델
- 시스템 전반에서 시간에 따른 상태 변경이 전달 필요
- 어떤 부분의 변경이 다른 부분의 상태에 의존시, 프로그램이 상태 변수를 변경하지 않음
- 데이터 요소간 의존관계를 선언하고 런타임이 대신 상태를 전달
- 사용자는 함수형의 선언적이고 조합이 가능한 관용구를 활용해 코드 작성 가능

##### 반응형 확장(Rx)
- 이벤트의 스트림이나 다른 데이터 소스를 표현하는 **관찰 가능한 시퀀스** 를 사용해 비동기적 프로그램 구성
- `LINQ`라는 라이브러리가 제공하는 여러 질의 연산자(콤비네이터)를 함께 활용

#### 반응형 선언
- 반응형 시스템이 어떤 것이어야 하는가에 대한 정의
- 확장성이 있고 회복성이 있는 반응형 애플맄이션이 지원해야 하는 네 가지 특성

##### 메시지 또는 이벤트 주도
- 시스템은 메시지나 이벤트에 응답하도록 설계되어야 한다

##### 탄력성 & 확장성
- 수요를 만족시키기 위한 확장성
- 프로세스, 코어, 노드 경계를 넘어서는 수평적인 확장
- 이상적인 경우 이런 과정은 수용의 변화에 대한 응답으로 동적으로 일어나며, 확장/축소가 모두 가능
- 네트워크의 특성(성능 혹은 신뢰성)이 가장 우선적인 관심사로 대두

##### 회복성
- 시스템의 크기가 커짐에 따라 실패 가능성 증가
- 실패시에도 처음부터 부드럽게 회복될 수 있도록 주의깊게 만들어져야 함

##### 응답성
- 시스템은 서비스 요청에 응답하기 위해 항상 사용 가능
- 일부 구성요소가 실패하거나 높은 트래픽 발생으로 성능을 부드럽게 낮출 필요가 있는 경우에도 응답성 보장

---
- 액터, FRP, Rx
  - **이벤트 주도**
  - 각자의 방식으로 **확장성**, **응답성** 제공
  - 블로킹 최소화
- FRP, Rx
  - 개별 스트림이나 이벤트를 위한 배관을 처리하는 데 좀 더 집중 (**확장성**)
- 액터
  - 상호 작용하는 구성 요소의 연결에 집중 (**확장성**)
  - 튼튼한 오류처리 전략으로 가장 높은 **응답성** 제공

## 17.7 마치며

#### 배운 것
- 대규모 시스템을 위해 규모 확장성이 있고, 튼튼한 동시성 애플리케이션을 아카 액터를 사용해서 만드는 방법
- 스칼라의 프로세스 관리와 퓨처 지원
- 일반적인 **반응형** 프로그래밍의 아이디어
ㅇ
#### 배울 것
- **빅데이터** 업계에서 왜 스칼라가 주목받는가
