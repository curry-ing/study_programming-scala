# 16. 고급 함수형 프로그래밍

- 대수적 데이터 타입(algebraic data type)
- 카테고리 이론(category theory)
- 모나드(monad)

## 16.1 대수적 데이터 타입
- 데이터 타입이 대수적인 수학적 특성을 만족
  -> 데이터 타입에 대한 증명을 가능하게 하고 이는 데이터 타입에 대한 자신감을 키운다


### 16.1.1 합 타입과 곱 타입
#### 곱 타입
- 우리가 접하는 대부분의 클래스

```scala
case class Person(name: Name, age: Age)
```
- 허용 가능한 `Name`과 `Age` 수를 곱한만큼의 `Person`인스턴스 생성 가능
- `TupleN`, `Product`(`case class`의 부모 타입)등이 곱 타입에서 파생

##### 곱 타입에 대해 `1`의 역할을 하는 타입: `Unit`
- `Unit`의 유일한 인스턴스명 -> `()`(길이가 0인 튜플)
- 곱셈의 항으로 볼때 `()`는 타입 인스턴스의 개수에 1을 **곱하는** 것과 동일
```scala
type unitTimesTuple2 = (Int, String, Unit)
```
- 위 타입의 인스턴스 개수는 `(Int, String)`의 인스턴스 개수와 동일

##### 곱 타입에 대해 `0`의 역할을 하는 타입: `Nothing`
- `Nothing`: 인스턴스가 하나도 없는 타입
- 어떤 인스턴스의 내부에는 `Nothing`인 필드가 *거주* 할 수 없음

#### 합 타입
- 열거형이 대표적인 합 타입 [enumeration.sc](../src/main/scala/rounding/enumeration.sc)
- 싱글턴 객체에 대한 봉인한 계층구조 생성 [sealed_trait.sc](../src/main/scala/rounding/sealed_trait.sc)

> **열거형**: 읽기 쉬운 문자열 표현을 제공하는 플래그 만 필요로 할 경우
**봉인된 싱글턴 객체 계층구조**: **열거형** 보다 더 많은 상태 정보를 수용


### 16.1.2 대수적 데이터 타입의 특성

#### 대수(algebra)를 정의하는 세 가지 측면
- **대상물**: 보통은 수를 대상으로 하지만, 어떤 것이든 될 수 있다
- **연산**: 각 원소를 조합해서 새로운 원소를 만들어내는 방식
- **법칙**: 연산과 원소 사이 관계를 정의 (ex> 결합법칙: `(x + (y + z)) == ((x + y) + z)`)

#### 곱 타입의 예
```scala
Unit * (Int, String) == (Int, String) * Unit
```  
- 교환 법칙이 존재 (`1 * N = N * 1`)
- `Unit`이 아닌 다른 타입의 경우(`Nothing` 포함)에도 성립

#### 합 타입의 예
- 집합의 모든 원소는 유일
- `Nothing`, `Unit` 어떤것을 더해도 결합법칙이 성립
```scala
Nothing + (doberman, yorkie, ...) == (dorberman, yorkie, ...) + Nothing
Unit    + (doberman, yorkie, ...) == (dorberman, yorkie, ...) + Unit
Person  + (doberman, yorkie, ...) == (dorberman, yorkie, ...) + Person
```

**분배 법칙** 도 성립: `x * (a + b) = x * a + x * b`


### 16.1.3 대수적 데이터 타입에 대한 마지막 고찰
#### 생성하는 타입에 대한 정확한 추론
- 정확한 의미를 내포하는가?
- 타입에 의미가 있는 값만 들어가도록 하는 적절한 제약이 걸려 있는가?
- 그 타입을 가지고 정확한 행동방식을 제공하는 새로운 타입을 조합할 수 이는가?

#### `List`타입의 예
- `Nil` - 빈 리스트 서브타입
- `::` - 값이 있는 리스트 서브타입
- 너무 당연해 보이지만, 이 두 타입을 가지고 모든 리스트를 구성하고, 어떻게 작동할지 정확히 추론 가능


## 16.2 카테고리 이론
- 카테고리 이론은 수학적 기반 위에 있다 (어렵다)
- 모든 수학을 전역적인 특성에 대해 추론할 수 있는 형태로 일반화하여 **멀고 깊은 추상화** 가능
- **고급 함수형 프로그래밍** 에서 중요한 부분

### 16.2.1 카테고리란 무엇인가
#### 카테고리를 정의하는 세 가지 실체
- **대상물**(object) 의 집합인 **모임**(class): OOP의 클래스와 동일한 의미는 아니나, 함의하는 바는 비슷  
- **사상의 모임**(class of morphism): **화살표**(arrow)라고 불리기도 하며 함수를 더 일반화 한 개념  
  - f: A -> B (f: A => B in Scala)
  - 각각의 사상 `f`에서... *한 대상*: `f`의 **정의역**(domain), *다른 하나*: **공역**(codomain)
  - *대상* 이 단수인 이유: 일부 카테고리에서는 **대상** 자체가 값의 모임이거나, 다른 카테고리의 모임
- **사상 합성**(morphism composition): `f: A -> B` 이고 `g: B -> C`일때 합성 `g ◦ f: A -> C`가 존재한다는 특성을 가지는 **2항 연산**(binary operation)

#### 사상 합성이 만족시키는 두 가지 정리
- 각 대상 x에는 항등 사상이 오직 하나만 존재
  - 정의역과 공역이 같은 경우로 `IDx` 라고 쓰며, `f ◦ IDx = IDx ◦ f`특성을 만족
- **결합 법칙** 만족
  - `f: A -> B`, `g: B -> C`, `h: C -> D` 에 대해 `(f ◦ g) ◦ h = f ◦ (g ◦ h)`

### 16.2.2 펑터 카테고리
- 펑터는 `map` 연산을 추상화
- 15.6 절 **타입 람다** 참조
- 다음 예제에서는 먼저 추상화를 정의하고 그 다음 세 가지 구체적인 타입 `Seq`, `Optoin`, `A=>B`를 구현

[Functor.scala](../src/main/scala/fp/categories/Functor.scala)

- `FunctionF`는 단순하지 않다
- 초기 타입 `A`를 바꾸려는 것이 아니고 `A2`를 입력으로 받는 두 번째 함수 `f`를 `func`의 `A2` 출력에 연쇄시키려는 것
- `map`연산이 들어있는 매개변수화한 타입: **펑터**

[Functor.sc](../src/main/scala/fp/categories/Functor.sc)

```scala
def map[A, B](seq: Seq[A])(f: A => B): Seq[B] = seq map f

def map[A, B](f: A => B)(seq: Seq[A]): Seq[B] = seq map f
```
- 위 두번째 예제에서 반환되는 새 함수의 타입 : `Seq[Int] => Seq[Double] = <function1>`
- `map`메서드는 `A => B`라는 함수를 `Seq[A] => Seq[B]`로 **끌어올림**
- 일반적으로 `Functor.map`은 대부분의 `F`에 대해 `A => B`로, 모든 타입 A와 B에 대해 `F[A] => F[B]`로 사상시킨다
  - **펑터** 를 사용하면 순수함수 `(f: A => B)`를 하나 이상의 `A`값을 포함하는 *맥락* 에 적용할 수 있다.
  - `f`를 적용하고, 그 결과를 *맥락* 의 새 인스턴스에 넣기 위해 이런 값을 직접 뽑아낼 필요는 없다
  -> **펑터 라는 용어는 순수 함수를 이런 방식으로 사용할 수 있게 해주는 추상화**

##### 카테고리 이론의 용어로 표현하자면...
- 다른 카테고리: **대상**
- 카테고리 사이의 매핑: **사상**
- `List[Int]`와 `List[String]`은 각각의 대상이 모든 `Int`의 리스트와 모든 `String`의 리스트인 두 카테고리

- Functor는 카테고리 이론의 공통 특성ㅇ과 정리 외에 다음 두 특성을 추가로 만족
  1. 펑터 F는 단위원(항등원)을 유지. 즉, **정의역** 의 단위원은 **공역** 의 단위원으로 사상
  2. 펑터 F는 합성을 유지한다. 즉, `F(f ◦ g) = F(f) ◦ F(g)`

[FunctorProperties.scala](../src/main/scala/fp/categories/FunctorProperties.scala)

### 16.2.3 모나드 카테고리

### 16.2.3 모나드의 중요성

## 16.3 마치며
