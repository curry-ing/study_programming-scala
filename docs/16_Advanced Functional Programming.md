# 16. 고급 함수형 프로그래밍

- 대수적 데이터 타입(algebraic data type)
- 카테고리 이론(category theory)
- 모나드(monad)

## 16.1 대수적 데이터 타입
- 데이터 타입이 대수적인 수학적 특성을 만족
  -> 데이터 타입에 대한 증명을 가능하게 하고 이는 데이터 타입에 대한 자신감을 키운다


### 16.1.1 합 타입과 곱 타입
#### 곱 타입
- 우리가 접하는 대부분의 클래스

```scala
case class Person(name: Name, age: Age)
```
- 허용 가능한 `Name`과 `Age` 수를 곱한만큼의 `Person`인스턴스 생성 가능
- `TupleN`, `Product`(`case class`의 부모 타입)등이 곱 타입에서 파생

##### 곱 타입에 대해 `1`의 역할을 하는 타입: `Unit`
- `Unit`의 유일한 인스턴스명 -> `()`(길이가 0인 튜플)
- 곱셈의 항으로 볼때 `()`는 타입 인스턴스의 개수에 1을 **곱하는** 것과 동일
```scala
type unitTimesTuple2 = (Int, String, Unit)
```
- 위 타입의 인스턴스 개수는 `(Int, String)`의 인스턴스 개수와 동일

##### 곱 타입에 대해 `0`의 역할을 하는 타입: `Nothing`
- `Nothing`: 인스턴스가 하나도 없는 타입
- 어떤 인스턴스의 내부에는 `Nothing`인 필드가 *거주* 할 수 없음

#### 합 타입
- 열거형이 대표적인 합 타입
- 싱글턴 객체에 대한 봉인한 계층구조 생성

> **열거형**: 읽기 쉬운 문자열 표현을 제공하는 플래그 만 필요로 할 경우
**봉인된 싱글턴 객체 계층구조**: **열거형** 보다 더 많은 상태 정보를 수용


### 16.1.2 대수적 데이터 타입의 특성

#### 대수(algebra)를 정의하는 세 가지 측면
1. **대상물**: 보통은 수를 대상으로 하지만, 어떤 것이든 될 수 있다
2. **연산**: 각 원소를 조합해서 새로운 원소를 만들어내는 방식
3. **법칙**: 연산과 원소 사이 관계를 정의 (ex> 결합법칙: `(x + (y + z)) == ((x + y) + z)`)

#### 곱 타입의 예
```scala
Unit * (Int, String) == (Int, String) * Unit
```  
- 교환 법칙이 존재 (`1 * N = N * 1`)
- `Unit`이 아닌 다른 타입의 경우(`Nothing` 포함)에도 성립

#### 합 타입의 예
- 집합의 모든 원소는 유일
- `Nothing`, `Unit` 어떤것을 더해도 결합법칙이 성립
```scala
Nothing + (doberman, yorkie, ...) == (dorberman, yorkie, ...) + Nothing
Unit    + (doberman, yorkie, ...) == (dorberman, yorkie, ...) + Unit
Person  + (doberman, yorkie, ...) == (dorberman, yorkie, ...) + Person
```

**분배 법칙** 도 성립: `x * (a + b) = x * a + x * b`


### 16.1.3 대수적 데이터 타입에 대한 마지막 고찰
#### 생성하는 타입에 대한 정확한 추론
- 정확한 의미를 내포하는가?
- 타입에 의미가 있는 값만 들어가도록 하는 적절한 제약이 걸려 있는가?
- 그 타입을 가지고 정확한 행동방식을 제공하는 새로운 타입을 조합할 수 이는가?

#### `List`타입의 예
- `Nil` - 빈 리스트 서브타입
- `::` - 값이 있는 리스트 서브타입
- 너무 당연해 보이지만, 이 두 타입을 가지고 모든 리스트를 구성하고, 어떻게 작동할지 정확히 추론 가능
